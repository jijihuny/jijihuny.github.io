---
title: "IPv4 주소 : 네트워크-7"
date: 2024-05-10
tags: [네트워크]
---

# Overview

하위 데이터링크 계층엔 Mac 주소가 존재합니다.
그런데 왜 IP 주소 개념이 등장한 걸까요?

Mac 주소에는 범용적인 어떤 구조가 없습니다.
따라서 Mac 주소는 switch에게 목적지에 대한 식별자(일종의 주민번호)로서 역할을 할 순 있지만, 그 위치에 대한 정보(주소로서의 정보)를 제공하진 못합니다.

즉, 새로운 Mac 주소가 정확히 어떤 포트에 있는 호스트를 지징하는지 알지 못하면 switch는 일단 broadcasting을 통해 모든 호스트로 데이터를 보낼 수 밖에 없습니다.

switch table의 크기도 문제가 됩니다.
기본적으로 모든 Mac 주소를 포트와 대응시키는 엔트리를 추가해야 하기 때문에 mac 주소 개수만큼 테이블 크기가 커져야합니다.

![alt text](/blog/addressing/image.png)

# IP 주소

인터넷에 연결되는 모든 장치(라우터를 포함하여)는 반드시 고유한 IP 주소를 보유합니다.

![alt text](/blog/addressing/image-1.png)

IP 주소는 32비트 값으로 보통 그림과 같이 8비트를 하나의 word로 묶어 "."으로 분리된 4개의 word로 표현합니다.
또한 이진수 표기가 불편하니 십진수로 0~255값으로 변환하여 표현하게 됩니다.

IP 주소는 어떻게 장치에 부여될까요?

위에서 말씀드렸듯, Mac 주소는 일종의 주민등록번호라면, IP 주소는 집주소에 해당합니다.

집 주소는 집의 지리적, 행정적 위치 정보를 구조적으로 반영하여 지정됩니다.

IP 주소도 인터넷 상의 어떠한 구조적 정보를 반영해야만 하는데요.

인터넷은 네트워크들의 네트워크입니다.

따라서 IP 주소는 네트워크의 정보를 구조적으로 반영하도록 설계됩니다.

계속해서 살펴봅시다.

# IP 주소 할당

IP 주소는 장치가 속한 네트워크의 구조적 정보를 반영해야만 합니다.

장치의 고유정보와는 달리 네트워크는 물리적 환경에 의해 얼마든지 변동될 수 있는 요인입니다.

따라서 IP 주소의 할당은 기본적으로 장치가 속한 네트워크에 의해 결정되는데요.

크게 두 가지 방식이 있습니다.

1. Static address

컴퓨터의 네트워크 셋팅을 통해 설정할 수 있습니다.
한 번 설정하면 변경하기 전까지 계속해서 변하지 않고 유지됩니다.
물론 마음대로 아무것이나 할 수 있는 것은 아니고 속해있는 네트워크 상황에 따라 할당할 수 있습니다.(네트워크의 구조적 특성을 반영해야 하기 때문입니다.)

2. Dynamic address

가장 흔히 사용되는 방식으로 주로 DHCP(Dynamic Host Configuration Protocol)에 의해 설정됩니다.

DHCP는 주로 라우터나 DHCP 서버에 의해 수행되는데, 동적 할당이란 말은 IP 주소를 잠시 임대한다는 의미와 비슷합니다.

할당받은 IP 주소는 한정된 시간 동안만 유효하며 만약 기간이 만료되면 장치는 자동적으로 새로운 IP 주소를 요청합니다.

IP 주소는 32비트 값이므로 약 40억개 정도의 IP 주소의 공간을 가집니다.

그 중 일부는 테스트, loopback 등의 용도로 예약된 주소로 공용 주소(인터넷에 접속하기 위한 주소)로는 사용할 수 가 없으므로 조금 더 줄어듭니다.

인터넷이 등장하던 초창기에는 기본적으로 군사, 연구 목적으로 개발된 것이었기 때문에 지금처럼 많은 인터넷 수요가 있지 않았습니다.

현대에 인터넷에 접속하려는 기기가 얼마나 많을까요?
스마트폰, 개인용 컴퓨터, 키오스크, 자동차, .. 

정말 정말 많은 장치들이 인터넷 주소를 필요로 하고 있을 겁니다.

40억개는 이제 턱없이 부족하다고 말해도 무방할 정도입니다.

이에 IPv4로는 더이상의 주소공간 수요를 감당할 수 없어 IPv6가 등장하는데요.

오늘은 IPv6를 얘기하는 시간이 아니기 때문에 우선 IPv4가 늘어나는 주소 공간에 대한 수요를 어떻게 감당하는지 알아보도록 할 것입니다.

# Classful Address

우선 IP가 설계되던 초창기에는 네트워크 주소를 class에 따라 나누었습니다.

![alt text](/blog/addressing/image-2.png)

A class는 상위 1바이트
B class는 상위 2바이트
C class는 상위 3바이트를 네트워크 주소로 가지는 IP 주소 공간으로 설정한 것입니다.

이게 무슨 말일까요?

IP 주소는 네트워크 주소와 호스트 주소로 분할할 수가 있습니다.

예를 들면 1바이트 네트워크 주소를 가지는 IP 주소 125.15.1.1
이 있다면

이 주소는 네트워크 주소 125.0.0.0과 호스트 주소 15.1.1로 분할 할 수 있는 것 입니다.

마치 우리 집 주소가 "인천 미추홀구 / ~로 ~길" 이런 식으로 구조적으로 작성된 것과 같습니다.

Classful address는 네트워크 주소를 1, 2, 3바이트로 사용하고 각각 3, 2, 1바이트를 호스트 주소로 사용하자는 규칙을 정한 것 입니다.

Class는 어떻게 구분할 수 있을까요?

이를 위해 prefix를 통해 구분할 수 있도록 해놓았습니다.

![alt text](/blog/addressing/image-3.png)

첫 1bit가 0이라면 A, 10이라면 B, 110이라면 C, ..
이런 식으로 leading 0의 위치를 통해 손쉽게 Class를 구분할 수 있도록 해놓았습니다.

굳이 왜 숫자를 0, 10, 110, 1110 이런 식으로 해놓았냐면 최소한의 숫자 비교만으로 Class를 비교할 수 있기 때문입니다.

이제 왜 이렇게 class마다 네트워크 주소의 길이를 다르게 하였는지 알아보도록 합시다.

![alt text](/blog/addressing/image-4.png)

class A 주소를 할당받은 네트워크의 호스트 개수를 명시한 것입니다.

만약 네트워크 id로 73(73.0.0.0)을 할당받았다면 하위에 몇 개의 호스트 주소를 가질 수 있을 까요?

73.0.0.0 ~ 73.255.255.255로 
$2^{24}=$ 약 1600만개 주소를 가질 수 있습니다.

그 중 73.0.0.0은 네트워크 주소, 73.255.255.255는 broadcasting을 위한 주소로 사용하여 -2를 해야하지만 이는 큰 숫자는 아니죠.

따라서 class A의 경우 매우 큰 주소 공간이 필요한 네트워크에, class B의 경우 중간 정도, class C의 경우 작은 개수만 필요한 네트워크에 할당하면, fixed length로 네트워크 주소를 설정하는 것에 비해 조금은 주소 낭비를 막을 수 있을 겁니다.

## Reserved, special address

IP 주소 공간에는 여러가지 용도의 예약 주소가 존재합니다.

1. Loopback interface

127.0.0.1 ~ 127.255.255.255는 loopback 인터페이스로 정의합니다.

이는 자기자신으로 돌아오는 주소를 뜻하는데요.

프로그래밍 언어의 self 혹은 this 문법과 유사한 의미로 생각하면 좋을 것 같습니다.

주로 127.0.0.1로 많이 사용하고, DNS를 통한 표기로 "localhost"라고 표시합니다.

2. Network 주소

어떤 네트워크가 상위 N 바이트를 Network Id로 가진 다면 하위 32 - N 바이트를 모두 0으로 설정했을 때(ex. 73.0.0.0)을 네트워크 주소로 칭합니다.

3. Broadcast 주소

Network 주소와 마찬가지로 하위 호스트 비트를 모두 1로 설정하면(ex. 73.255.255.255) broadcast 주소라고 칭합니다.

이러한 주소로 보낸 패킷은 네트워크 상의 모든 호스트를 목적지로 하는데요.

실제로는 보안 등의 우려로 이를 허용하지 않는 경우도 있습니다.

4. Test/Experimental

테스트와 실험 용도로 예약된 주소 공간도 있습니다.

10.0.0.0 ~ 10.255.255.255
172.16.0.0 ~ 172.31.255.255
192.168.0.0 ~ 192.168.255.255

이러한 주소를 목적지로 하는 패킷은 네트워크에서 폐기되어버립니다.

5. Convention

기본 게이트웨이(기본 라우터)는 보통 네트워크의 첫 번째 호스트 주소로 설정합니다.

ex. 192.0.1.1


# Subnet

Classful Address는 어떤 문제를 가지고 있었을까요?

기본적으로 Classful Address는 주소 공간을 24바이트, 16바이트, 8바이트 크기로만 나누게 됩니다.

각각 약 1600만, 약 6만, 253개의 호스트 주소를 할당할 수 있게 되는데요.

만약 800개 정도의 주소가 필요한 기관은 어떻게 해야할까요?

class B의 주소를 할당받을 경우 무려 6만개나 되는 주소공간 대부분을 비워두고 낭비하게 될 겁니다.

혹은 class C의 네트워크 주소 4개를 할당받는 방법도 있긴 하겠지만 한 기관에서 관리해야 할 네트워크가 4개로 늘어나게 됩니다.

혹은 3만개 정도의 주소가 필요하다면?
또한 네트워크 주소는 마음대로 할당받을 수 있는게 아니고 대륙, 국가 별로 IP 주소를 관리하는 기관에게 승인을 받아야만 하는 부분입니다.

이러힌 문제는 결국 IP 주소 공간이 필연적으로 아주 많이 낭비되는 결과를 만들었는데요.

초창기 인터넷에선 사용자가 그리 많지 않아 상관없었지만, 시대가 지나며 인터넷 사용자가 증가하며 급증하여 IP 주소 공간을 효율적으로 사용할 방법이 꼭 필요했습니다.

이에 IP 주소에 새로운 계층 구조를 추가하게 되는데요.

새로운 계층 구조를 **subnet**이라고 부릅니다.

이제 IP 주소는 네트워크 주소 아래 서브네트워크 주소로 새로운 구조를 추가합니다.

서브넷은 하나의 기관 네트워크를 다시 여러 개의 작은 네트워크로 나눈 것을 말합니다.

따라서 최상위 네트워크 내에서만 식별될 수 있고, subnet의 같은 서브넷에 속한 호스트는 반드시 같은 subnet id를 가져야 합니다.

어느정도 고정된 길이를 가졌던 최상위 네트워크 id에 비해 subnet id는 유연하게 표현될 수도 있는데요.

![alt text](/blog/addressing/image-5.png)

subnet id를 식별하는 방법은 위 그림에서 볼 수 있듯 subnet mask를 추가하는 것인데요.
mask와 IP 주소를 bitwise and op을 통해 계산하면 subnet 주소를 알 수 있습니다.

따라서 라우팅 테이블에도 IP 주소 + subnet 마스크를 추가하게 됩니다.

![alt text](/blog/addressing/image-6.png)

위 그림과 같이 라우터와 인터페이스가 정의되었을 때,

만약 R2로부터의 라우팅 테이블을 정의하면 아래와 같이 될 수 있을 겁니다.

![alt text](/blog/addressing/image-7.png)

# CIDR(Classless InterDomain Routing)

서브넷팅을 통해 하나의 네트워크를 여러 작은 네트워크로 유연하게 나누고, 주소 공간의 낭비를 막았습니다.
그럼에도 최상위 네트워크 주소에선 classful address 할당이 유지되기 때문에 주소 할당의 유연성에 한계가 존재하였습니다.
또한 기존 subnetting은 라우팅 테이블에 반드시 서브넷 마스크를 표시해야 하는데, 이는 라우팅 테이블 공간을 늘리는 요인이기도 했습니다.

이에 IP 주소 공간을 아예 임의의 길이를 가지는 network id와 나머지 host id로 해석하도록 변화하는데요.

이러한 IP 주소 공간 해석을 CIDR이라고 부릅니다.
기존의 class 방식의 표기를 버렸기 때문에 이제는 network id의 길이를 반드시 함께 제공받아야 합니다.

CIDR 표기는 IP address/prefix length와 같이 하는데요.

예를 들면 192.0.2.0/18 이런 식입니다.
prefix length = 18은 subnet mask = 255.255.255.0과 동일한 역할을 하는데요.
즉 상위 18비트가 네트워크 주소라는 의미입니다.

이에 따라 CIDR 표기는 네트워크 주소를 표현할 때 하위 zeros를 버리는 표기도 허용합니다.

192.0.2.0/18 = 192.0.2/18

## CIDR address blocks

만약 ISP(Internet Service Provider)가 206.0.64.0/18 주소 블록을 소유했다고 가정합시다.

어떤 클라이언트가 800개의 주소 공간을 요청한다면, 어떻게 해야할까요?

기존의 방식으론 class B 주소를 새로 하나 할당해 약 6만개의 주소를 낭비하거나, 4개의 class C 주소를 할당해 4개의 라우터를 추가해야만 할 것 입니다.

CIDR는 훨씬 효율적인 주소 할당이 가능한데, 206.0.68.0/22 주소 블록을 할당하여 클라이언트에게 1024개의 IP 주소 공간을 제공할 수 있게 됩니다.