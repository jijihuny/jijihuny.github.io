---
title: 직접 만들어보는 리액트
date: 2024-04-09
tags: [리액트]
---

## 직접 만들어보는 리액트
> 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리

리액트는 현재 사실상 사용자 인터페이스 개발을 위한 업계 표준이 되었다.
실제로 리액트를 간단히 구현해보며 리액트도 공부하고,
개발 실력도 향상시켜보자.

## 분석

우선 나는 리액트를 몇 번 써보지 못했다..

그래서 내가 아는 부분에 대해서만 작동하도록 해볼려 한다.

우선 리액트의 대표적 동작을 살펴보자.

```js

const Component = ()=> {
    const [state, setState] = useState(initialVal);

    return (
        <>
        <SomeComponent onClick={()=> setState(newVal)} />
        ...
        </>
    )
}

```

리액트의 패러다임이라고도 볼 수 있는 위의 코드는 setState를 통해 새로운 상태를 페이지에 반영한다.

이 때 리액트는 내부적으로

1. 이전 상태와 새로운 상태를 비교한다.
2. 상태가 달라졌을 경우 새로운 상태를 반영하여 새로운 virtual Dom을 생성한다.
3. 리액트는 내부적으로 이전 페이지의 virtual Dom을 저장해두었는데,
 이제 이전 virtual Dom과 새로운 virtual Dom을 비교하여 수정된 사항을 저장한다.
4. 마지막으로 리액트는 수정된 사항을 새로운 '실제' 페이지에 반영한다.

2.을 통해 우리는 실제 Dom을 모방한 가상의 자료구조를 생성해야 함을 우선 알 수 있다.
3.과 4.는 상당히 어려운 부분인데,

3.을 앞으로 Reconciliation(재조정), 4.을 Rendering(반영?)이라고 부르겠다.

우선 3.에서 고려할 점은 연속적 상태변화가 발생할 경우이다.

이전 상태와 새로운 상태로 트리를 비교하는 것은 시간이 꽤나 걸리는 일이다.
리액트는 heuristic 알고리즘을 통해 O(N) 시간에 트리 비교를 완료하는데,
그럼에도 O(N)이란 시간이 무시할 만한 시간이 아니다.

만약 복잡한 상태변화가 연쇄적으로 일어난다면,
비동기적으로 작동하는 자바스크립트의 특성상 동시성 문제가 발생하기 쉽다.

따라서 연쇄적 상태변화에서는 이전 비교 작업을 취소하고
가장 최신의 상태를 반영한 트리와 비교로 작업을 양도할 수 있어야만 한다.

두번째로 4.에서는 일종의 트랜젝션이 적용되어야 하는데,
만약 트리를 렌더링하는 도중,
새로운 상태변화가 일어나 새로운 트리 렌더링이 시작된다면?

기존 트리 렌더링 작업과 새로운 트리 렌더링 작업이 꼬일 가능성이 생겨버린다.

물론 실제 리액트는 좀 더 작업단위를 쪼개서 스케쥴링까지 하는 것 같은데,
여기선 거기까진 무리라 보고 4. 과정을 하나의 Atomic Operation으로 만들려고 한다.

## 설계

이제 대략적으로 설계를 해보자.

### Reconciler Part

우선 기존 트리와 새로운 트리를 비교해야 한다.
또한 변경된 사항을 기록할 필요가 있는데,
이는 일종의 Job Queue를 만들면 될 것이다.

앞서 말했듯 새로운 상태 변경이 일어나면 canclable해야 한다.

### Render